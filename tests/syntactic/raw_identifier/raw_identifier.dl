// Souffle - A Datalog Compiler
// Copyright (c) 2022, The Souffle Developers. All rights reserved
// Licensed under the Universal Permissive License v 1.0 as shown at:
// - https://opensource.org/licenses/UPL
// - <souffle root>/licenses/SOUFFLE-UPL.txt

.init r#comp = _c

.decl r#decl(u:number)
.decl r#functor(u:number)
.decl r#include(u:number)
.decl r#init(u:number)
.decl r#input(u:number)
.decl r#limitsize(u:number)
.decl r#number_type(u:number)
.decl r#once(u:number)
.decl r#output(u:number)
.decl r#override(u:number)
.decl r#plan(u:number)
.decl r#pragma(u:number)
.decl r#printsize(u:number)
.decl r#symbol_type(u:number)
.decl r#type(u:number)

.input r#decl()
.input r#functor()
.input r#include()
.input r#init()
.input r#input()
.input r#limitsize()
.input r#number_type()
.input r#once()
.input r#output()
.input r#override()
.input r#plan()
.input r#pragma()
.input r#printsize()
.input r#symbol_type()
.input r#type()

.decl r#as(u:number)
.decl r#min(u:number)
.decl r#autoinc(u:number)
.decl r#band(u:number)
.decl r#bnot(u:number)
.decl r#bor(u:number)
.decl r#brie(u:number)
.decl r#bshl(u:number)
.decl r#bshr(u:number)
.decl r#bshru(u:number)
.decl r#btree(u:number)
.decl r#btree_delete(u:number)
.decl r#bxor(u:number)
.decl r#cat(u:number)
.decl r#contains(u:number)
.decl r#count(u:number)
.decl r#eqrel(u:number)
.decl r#false(u:number)
.decl r#fold(u:number)
.decl r#inline(u:number)
.decl r#land(u:number)
.decl r#lnot(u:number)
.decl r#lor(u:number)
.decl r#lxor(u:number)
.decl r#magic(u:number)
.decl r#match(u:number)
.decl r#max(u:number)
.decl r#mean(u:number)
.decl r#nil(u:number)
.decl r#no_inline(u:number)
.decl r#no_magic(u:number)
.decl r#ord(u:number)
.decl r#overridable(u:number)
.decl r#range(u:number)
.decl r#stateful(u:number)
.decl r#strlen(u:number)
.decl r#substr(u:number)
.decl r#sum(u:number)
.decl r#to_float(u:number)
.decl r#to_number(u:number)
.decl r#to_string(u:number)
.decl r#to_unsigned(u:number)
.decl r#true(u:number)

.input r#as()
.input r#min()
.input r#autoinc()
.input r#band()
.input r#bnot()
.input r#bor()
.input r#brie()
.input r#bshl()
.input r#bshr()
.input r#bshru()
.input r#btree()
.input r#btree_delete()
.input r#bxor()
.input r#cat()
.input r#contains()
.input r#count()
.input r#eqrel()
.input r#false()
.input r#fold()
.input r#inline()
.input r#land()
.input r#lnot()
.input r#lor()
.input r#lxor()
.input r#magic()
.input r#match()
.input r#max()
.input r#mean()
.input r#nil()
.input r#no_inline()
.input r#no_magic()
.input r#ord()
.input r#overridable()
.input r#range()
.input r#stateful()
.input r#strlen()
.input r#substr()
.input r#sum()
.input r#to_float()
.input r#to_number()
.input r#to_string()
.input r#to_unsigned()
.input r#true()

.comp _c {
  .decl r#comp(u:number)
  .decl r#decl(u:number)
  .decl r#functor(u:number)
  .decl r#include(u:number)
  .decl r#init(u:number)
  .decl r#input(u:number)
  .decl r#limitsize(u:number)
  .decl r#number_type(u:number)
  .decl r#once(u:number)
  .decl r#output(u:number)
  .decl r#override(u:number)
  .decl r#plan(u:number)
  .decl r#pragma(u:number)
  .decl r#printsize(u:number)
  .decl r#symbol_type(u:number)
  .decl r#type(u:number)

  .decl r#as(u:number)
  .decl r#min(u:number)
  .decl r#autoinc(u:number)
  .decl r#band(u:number)
  .decl r#bnot(u:number)
  .decl r#bor(u:number)
  .decl r#brie(u:number)
  .decl r#bshl(u:number)
  .decl r#bshr(u:number)
  .decl r#bshru(u:number)
  .decl r#btree(u:number)
  .decl r#btree_delete(u:number)
  .decl r#bxor(u:number)
  .decl r#cat(u:number)
  .decl r#contains(u:number)
  .decl r#count(u:number)
  .decl r#eqrel(u:number)
  .decl r#false(u:number)
  .decl r#fold(u:number)
  .decl r#inline(u:number)
  .decl r#land(u:number)
  .decl r#lnot(u:number)
  .decl r#lor(u:number)
  .decl r#lxor(u:number)
  .decl r#magic(u:number)
  .decl r#match(u:number)
  .decl r#max(u:number)
  .decl r#mean(u:number)
  .decl r#nil(u:number)
  .decl r#no_inline(u:number)
  .decl r#no_magic(u:number)
  .decl r#ord(u:number)
  .decl r#overridable(u:number)
  .decl r#range(u:number)
  .decl r#stateful(u:number)
  .decl r#strlen(u:number)
  .decl r#substr(u:number)
  .decl r#sum(u:number)
  .decl r#to_float(u:number)
  .decl r#to_number(u:number)
  .decl r#to_string(u:number)
  .decl r#to_unsigned(u:number)
  .decl r#true(u:number)
}

.input r#comp.r#comp()
.input r#comp.r#decl()
.input r#comp.r#functor()
.input r#comp.r#include()
.input r#comp.r#init()
.input r#comp.r#input()
.input r#comp.r#limitsize()
.input r#comp.r#number_type()
.input r#comp.r#once()
.input r#comp.r#output()
.input r#comp.r#override()
.input r#comp.r#plan()
.input r#comp.r#pragma()
.input r#comp.r#printsize()
.input r#comp.r#symbol_type()
.input r#comp.r#type()

.input r#comp.r#as()
.input r#comp.r#min()
.input r#comp.r#autoinc()
.input r#comp.r#band()
.input r#comp.r#bnot()
.input r#comp.r#bor()
.input r#comp.r#brie()
.input r#comp.r#bshl()
.input r#comp.r#bshr()
.input r#comp.r#bshru()
.input r#comp.r#btree()
.input r#comp.r#btree_delete()
.input r#comp.r#bxor()
.input r#comp.r#cat()
.input r#comp.r#contains()
.input r#comp.r#count()
.input r#comp.r#eqrel()
.input r#comp.r#false()
.input r#comp.r#fold()
.input r#comp.r#inline()
.input r#comp.r#land()
.input r#comp.r#lnot()
.input r#comp.r#lor()
.input r#comp.r#lxor()
.input r#comp.r#magic()
.input r#comp.r#match()
.input r#comp.r#max()
.input r#comp.r#mean()
.input r#comp.r#nil()
.input r#comp.r#no_inline()
.input r#comp.r#no_magic()
.input r#comp.r#ord()
.input r#comp.r#overridable()
.input r#comp.r#range()
.input r#comp.r#stateful()
.input r#comp.r#strlen()
.input r#comp.r#substr()
.input r#comp.r#sum()
.input r#comp.r#to_float()
.input r#comp.r#to_number()
.input r#comp.r#to_string()
.input r#comp.r#to_unsigned()
.input r#comp.r#true()
